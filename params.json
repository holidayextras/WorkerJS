{"name":"WorkerJS","tagline":"Making concurrent Javascript easier","body":"##Introduction\r\n\r\nTLDR; WorkerJS makes it easy to write lightweight, concise, concurrent, clustered Javascript.\r\n\r\nWorkerJS makes it very easy to push functions from the main Javascript thread into the scope of a Worker by converting the webworker message passing interface into an RPC style interface. \r\n\r\nWorkerJS makes it very easy to pull Worker functionality back out into the main Javascript thread, exposing Worker functionality as RPC functions on an object. \r\n\r\nWorkerJS allows easy clustering of many Workers - all the Workers in a cluster appear as a single object, invoking a function on the cluster will send the request to every Worker in the cluster and the callback will fire when every Worker in the cluster has finished. \r\n\r\nWorkerJS can benchmark a users browser to determine the most effective number of Workers to spawn in order to maximise throughput.\r\n\r\n##Overview\r\n\r\nLet the main Javascript thread become a means for accessing shared memory - workers request interaction with the DOM, shared memory and each other via the 'Bridge'. It's an object containing a list of functions which are invoked by the main Javascript thread but are accessible by all 'Workers'. The 'Bridge' makes it simple to push data and functionality into the 'Workers'.\r\n\r\nOn the other side of things is the 'Gateway'. The 'Gateway' makes it easy for the main Javascript thread to request functionality of the 'Worker'. Functions defined within the 'Worker' are exposed as properties of an 'instance' object (which is passed into the 'Gateway' as a parameter). \r\n\r\nCalling a function on the 'instance' object within the 'Gateway' will cause the 'Worker' to invoke the same function, which can do all it's heavy processing and interact with the main Javascript thread via the functions in the 'Bridge'.\r\n\r\n\r\n```javascript\r\nvar theRestOfMyCode;\r\n\r\nWorkerJS({\r\n  // This is the 'Bridge'\r\n  // Functions defined here become global functions in the Worker.\r\n  // Functions defined here should sync data between Worker <-> theRestOfMyCode.\r\n}, function() { \r\n  // This is the 'Worker', it runs in a WebWorker (in a separate context).\r\n  // Functions defined in the Bridge exist in this global scope, nothing else\r\n  // outside of this function will be in scope.\r\n  // Functions defined here become properties of 'instance' in the Gateway.\r\n}, function(instance) {\r\n  // This is the 'Gateway', it allows interaction with the Worker.\r\n  // Functions defined in the Worker become properties of the 'instance' object.\r\n  // This function will only be invoked once.\r\n  // Invoking a function on 'instance' will call the function on the Worker.\r\n  // If the workerCount in the options is greater than 1, invoking a function on\r\n  // 'instance' will call the function on every Worker, if there is a callback\r\n  // to the function it will only be invoked once, and only when EVERY worker's\r\n  // function has invoked it's callback. Calling instance.terminate() will kill\r\n  // the worker(s).\r\n}, {\r\n  // WorkerCount. This parameter isn't required, it defaults to 1.\r\n  // Setting workerCount to (-1) will start a benchmark to determine the most \r\n  // effective number of workers the browser can handle, then proceed with that\r\n  // number.\r\n  workerCount: 1\r\n});\r\n```\r\n\r\n##Example Working with Primes\r\n\r\n```javascript\r\n// The goal is to populate this array with a bunch of prime numbers.\r\n// These variables can be considered shared memory.\r\nvar primes=[];\r\nvar finished = false;\r\n\r\nWorkerJS({ // TLDR; Functions we want to push into the Worker.\r\n  // 1. This is the 'Bridge'.\r\n  // 2. These functions are used by the Worker to interact with the main thread.\r\n  // 3. These functions are invoked in the normal main Javascript scope.\r\n  // 4. All functions get a callback parameter to send data back to the Worker.\r\n  addPrime: function(somePrime, callback) {\r\n    primes.push(somePrime);\r\n    callback();\r\n  },\r\n}, function() { // TLDR; Definition of a Worker.\r\n  // 1. This is the 'Worker'.\r\n  // 2. This code runs in parallel, in a totally separate WebWorker scope. \r\n  // 3. Functions in the Bridge will be available in this global scope.\r\n  // 4. Functions defined in the Worker will become properties in the Gateway.\r\n  // 5. All functions get a callback parameter to send data to the main scope.\r\n  // 6. WorkerJS provides the functions 'log' and 'warn' to help with debugging.\r\n  function findPrimesBetween(a, b, callback) {\r\n    log(\"Searching for primes between\", a, \"and\", b);\r\n    \r\n    for (var i=a; i<b; i++) {\r\n      var prime = true;\r\n      for (var j=2; j<i; j++) {\r\n        if ( (i%j) == 0 ) {\r\n          prime = false;\r\n          break;\r\n        }\r\n      }\r\n      if (prime) addPrime(i);\r\n    }\r\n    callback({ result: \"success\" });\r\n  };\r\n}, function(instance) { // TLDR; Interacting with the Worker.\r\n  // 1. This is the 'Gateway'.\r\n  // 2. 'instance' has a property for each function defined in the Worker.\r\n  // 3. Each function defined in the Worker gains a callback parameter.\r\n  instance.findPrimesBetween(2, 1000000, function(result) {\r\n    console.log(\"Primes between 2 and 1000000:\", primes);\r\n    finished = true;\r\n    instance.terminate(); // we're done - kill off our worker\r\n  });\r\n});\r\n\r\n// This demonstrates the parallel nature of this demo.\r\nvar checkProgress = function() {\r\n  console.log(\"Found\", primes.length, \"primes\");\r\n  if (!finished) setTimeout(checkProgress, 1000);\r\n};\r\ncheckProgress();\r\n```\r\n\r\n## More Effective Example\r\n\r\nThis example uses a cluster of workers to get the job done much MUCH faster. If you run this example you'll see it run a quick benchmark to determine how many workers the browser can effectively use - it will then spawn that many workers in a cluster. The Gateway only gets invoked once, and calling instances.testIfPrime() invokes the function on each of the clustered workers. The callback fires once all the worker's functions callback. The Bridge allows each Worker to request work units from main thread and write their output back to the main thread. Pretty neat.\r\n\r\n```javascript\r\nvar primes=[];\r\nvar unit = 1;\r\nvar finished = false;\r\n\r\nWorkerJS({ // TLDR; Functions we want to push into the Worker scope.\r\n  addPrime: function(somePrime, callback) {\r\n    primes.push(somePrime);\r\n    callback();\r\n  },\r\n  getUnit: function(callback) {\r\n    callback(unit++);\r\n  }\r\n}, function() { // TLDR; Definition of a Worker.\r\n  function testIfPrime(callback) {\r\n    var self = this;\r\n    \r\n    var processNextUnit = function() {\r\n      getUnit(function(i) {\r\n        if (i>200000) return callback(\"Success\");\r\n        var prime = true;\r\n        for (var j=2; j<i; j++) {\r\n          if ( (i%j) == 0 ) {\r\n            prime = false;\r\n            break;\r\n          }\r\n        }\r\n        if (prime) addPrime(i);\r\n        return processNextUnit();\r\n      });\r\n    };\r\n    processNextUnit();\r\n  };\r\n}, function(instances) { // TLDR; Interacting with the Worker(s).\r\n  console.log(\"Gateway has been called.\");\r\n  \r\n  var checkProgress = function() {\r\n    console.log(\"Found\", primes.length, \"primes\");\r\n    if (!finished) setTimeout(checkProgress, 1000);\r\n  };\r\n  checkProgress();\r\n  \r\n  var now = new Date();\r\n  instances.testIfPrime(function(result) {\r\n    console.log(\"Gateway callback - Done!\", primes, result);\r\n    console.log(\"Duration:\", (new Date())-now, \"ms\");\r\n    finished = true;\r\n    instances.terminate();\r\n  });\r\n}, { workerCount: -1 });\r\n```\r\nSample Console Output:\r\n```\r\nComputing most effective number of workers... \r\nBenchmark [ 1 workers ] 258 ms - 29 units processed\r\nBenchmark [ 2 workers ] 260 ms - 61 units processed\r\nBenchmark [ 3 workers ] 261 ms - 91 units processed\r\nBenchmark [ 4 workers ] 260 ms - 133 units processed\r\nBenchmark [ 5 workers ] 258 ms - 163 units processed\r\nBenchmark [ 6 workers ] 258 ms - 219 units processed\r\nBenchmark [ 7 workers ] 260 ms - 276 units processed\r\nBenchmark [ 8 workers ] 262 ms - 303 units processed\r\nBenchmark [ 9 workers ] 259 ms - 348 units processed\r\nBenchmark [ 10 workers ] 261 ms - 426 units processed\r\nBenchmark [ 11 workers ] 260 ms - 415 units processed\r\nStarting 10 workers\r\nGateway has been called.\r\nFound 0 primes\r\nFound 2541 primes \r\nFound 4755 primes \r\nFound 6680 primes \r\nFound 8623 primes \r\nFound 10464 primes \r\nFound 12190 primes \r\nFound 13872 primes \r\nFound 15462 primes \r\nFound 16985 primes \r\nGateway callback - Done! \r\n[3, 2, 5, 7, 1, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71â€¦]\r\nDuration: 9691 ms\r\nFound 17985 primes \r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}